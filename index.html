# fitness_agent.py
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from typing import Optional, List
from datetime import datetime, timedelta
import sqlite3
import math

DB = "fitness_agent.db"

# ---------- Utilities ----------
def init_db():
    conn = sqlite3.connect(DB)
    c = conn.cursor()
    c.execute("""CREATE TABLE IF NOT EXISTS users (
        id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT, dob TEXT, sex TEXT,
        height_cm REAL, weight_kg REAL, activity_level TEXT
    )""")
    c.execute("""CREATE TABLE IF NOT EXISTS activities (
        id INTEGER PRIMARY KEY AUTOINCREMENT, user_id INTEGER, type TEXT,
        start_time TEXT, duration_min REAL, distance_km REAL, steps INTEGER,
        calories REAL
    )""")
    conn.commit()
    conn.close()

def query_db(query, params=(), one=False):
    conn = sqlite3.connect(DB)
    c = conn.cursor()
    c.execute(query, params)
    rows = c.fetchall()
    conn.commit()
    conn.close()
    return rows[0] if one and rows else rows

# ---------- Calculators ----------
def bmi(weight_kg, height_cm):
    h = height_cm / 100.0
    return round(weight_kg / (h*h), 2)

def bmr_mifflin(weight_kg, height_cm, age, sex):
    # Mifflin-St Jeor
    if sex.lower() in ("m", "male"):
        s = 5
    else:
        s = -161
    return 10*weight_kg + 6.25*height_cm - 5*age + s

def calories_burned(activity_type, duration_min, user):
    # very simplified MET-based estimate
    mets = {
        "walking": 3.5,
        "running": 9.8,
        "cycling": 7.5,
        "yoga": 2.5,
        "strength": 6.0
    }
    met = mets.get(activity_type.lower(), 4.0)
    weight_kg = user["weight_kg"]
    kcal = (met * 3.5 * weight_kg / 200) * duration_min
    return round(kcal, 1)

# ---------- Pydantic models ----------
class UserCreate(BaseModel):
    name: str
    dob: str  # ISO date YYYY-MM-DD
    sex: str
    height_cm: float
    weight_kg: float
    activity_level: Optional[str] = "moderate"

class ActivityCreate(BaseModel):
    user_id: int
    type: str
    start_time: Optional[str] = None  # ISO datetime optional
    duration_min: float
    distance_km: Optional[float] = 0.0
    steps: Optional[int] = 0

app = FastAPI(title="Fitness Tracker Agent AI - Prototype")

# ---------- Startup ----------
@app.on_event("startup")
def startup():
    init_db()

# ---------- Endpoints ----------
@app.post("/users")
def create_user(u: UserCreate):
    query_db("INSERT INTO users (name,dob,sex,height_cm,weight_kg,activity_level) VALUES (?,?,?,?,?,?)",
             (u.name, u.dob, u.sex, u.height_cm, u.weight_kg, u.activity_level))
    rows = query_db("SELECT * FROM users ORDER BY id DESC LIMIT 1", one=True)
    return {"user": rows}

@app.get("/users/{user_id}")
def get_user(user_id: int):
    row = query_db("SELECT * FROM users WHERE id=?", (user_id,), one=True)
    if not row:
        raise HTTPException(404, "User not found")
    user = dict(zip(["id","name","dob","sex","height_cm","weight_kg","activity_level"], row))
    # compute derived
    birth = datetime.fromisoformat(user["dob"])
    age = int((datetime.utcnow() - birth).days / 365.25)
    user["age"] = age
    user["bmi"] = bmi(user["weight_kg"], user["height_cm"])
    user["bmr"] = bmr_mifflin(user["weight_kg"], user["height_cm"], age, user["sex"])
    return user

@app.post("/activities")
def add_activity(a: ActivityCreate):
    user_row = query_db("SELECT * FROM users WHERE id=?", (a.user_id,), one=True)
    if not user_row:
        raise HTTPException(404, "User not found")
    user = dict(zip(["id","name","dob","sex","height_cm","weight_kg","activity_level"], user_row))
    start_time = a.start_time or datetime.utcnow().isoformat()
    cals = calories_burned(a.type, a.duration_min, user)
    query_db("""INSERT INTO activities (user_id,type,start_time,duration_min,distance_km,steps,calories)
                VALUES (?,?,?,?,?,?,?)""", (a.user_id, a.type, start_time, a.duration_min, a.distance_km, a.steps, cals))
    last = query_db("SELECT * FROM activities ORDER BY id DESC LIMIT 1", one=True)
    return {"activity": last}

@app.get("/activities/user/{user_id}")
def list_activities(user_id: int, days: Optional[int] = 7):
    since = datetime.utcnow() - timedelta(days=days)
    rows = query_db("SELECT * FROM activities WHERE user_id=? AND start_time>=? ORDER BY start_time DESC",
                    (user_id, since.isoformat()))
    cols = ["id","user_id","type","start_time","duration_min","distance_km","steps","calories"]
    return [dict(zip(cols,r)) for r in rows]

# Simple chat-style assistant
@app.post("/assistant/{user_id}")
def assistant_query(user_id: int, payload: dict):
    # payload: {"query": "How many calories did I burn today?"}
    q = payload.get("query","").lower()
    if "calorie" in q or "burn" in q:
        rows = query_db("SELECT SUM(calories) FROM activities WHERE user_id=? AND start_time>=?",
                        (user_id, datetime.utcnow().replace(hour=0,minute=0,second=0).isoformat()), one=True)
        total = rows[0] if rows and rows[0] else 0
        return {"reply": f"You burned approximately {round(total,1)} kcal today from logged activities."}
    if "recommend" in q or "workout" in q:
        # very simple recommender (rule-based)
        user_row = query_db("SELECT * FROM users WHERE id=?", (user_id,), one=True)
        if not user_row:
            raise HTTPException(404, "User not found")
        user = dict(zip(["id","name","dob","sex","height_cm","weight_kg","activity_level"], user_row))
        bmi_v = bmi(user["weight_kg"], user["height_cm"])
        if bmi_v >= 25:
            plan = "30 min brisk walk + 20 min bodyweight strength (3x/week)."
        elif bmi_v < 18.5:
            plan = "Focus on caloric surplus + strength 3x/week."
        else:
            plan = "Mix of cardio 3x/week and strength 2x/week."
        return {"reply": f"Recommended: {plan}"}
    return {"reply": "Sorry - I don't understand. Try: 'How many calories did I burn today?' or 'Recommend a workout'."}
